---
title: 'Primer of Ecology with R: chapter 1'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: false
    number_sections: false
    theme: cerulean
    highlight: haddock
    code_folding: show
  pdf_document:
    toc: false
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(
  fig.width = 6, #sets default figure width
  fig.height = 4,#sets default figure height
  fig.path = 'Figs/lobster', #Sets default figure path (when knitting to pdf, figures are exported)
  echo = TRUE, #Show the code
  message = FALSE, #hide messages
  warning = FALSE #hide warnings
)

suppressPackageStartupMessages({
  ### The book has an R package! 
  library(primer) # install.packages('primer')
  library(cowplot)
  library(magrittr)
  library(tidyverse)
})
```

![](../img/slipper_lobster.jpg)

# Chapter 1 {.tabset}

## 1.3 Exploring Population Growth

#### Simple Graphing of Population Size (Fig. 1.3)

Here we create two vectors: population size, $N$, and years. Using `c()` allows us to create an arbitrary vector, and the colon, `:`, provides a sequence of consecutive integers.

```{r}
# Book default
N <- c(1, 3, 9, 27, 81)
year <- 2001:2005
plot(year, N)
```

```{r}
# JC
df <- tibble(N = c(1, 3, 9, 27, 81),
             year = 2001:2005)

ggplot(data = df,
       mapping = aes(x = year, y = N)) +
  geom_point() +
  theme_minimal()
```


The lily population (Fig. 1.3) increases by a different amount each year. What about proportions — does it increase by a different proportion each year? Let’s divide each year’s population size by the previous year’s size, that is, perform $N_{t+1}/N_t$ for all $t$, where $t$ is any particular point in time, and $t + 1$ is the next point in time. For $N$, that amounts to 3/1, 9/3, . . . . What do we notice?

#### Vectorized math

Here we divide each element of one vector (the second through fifth element of $N$) by each element of another vector (the first through fourth elements of $N$).

```{r}
# Book default
rates = N[2:5]/N[1:4]
rates
```

```{r}
# JC
df <- df %>% 
  mutate(rates = N / lag(N)) #We can use lag instead of subindexing for N
```


### 1.3.1 Projecting population size

Here we calculate population sizes for 10 time points beyond the initial. First we assign values for $N_0$, $\lambda$, and time.

```{r}
# Book default
N0 <- 1
lambda <- 2
time <- 0:10
```


Next we calculate $N_t$ directly using our general formula. 

``` {r}
# Book default
Nt <- N0 * lambda^time
Nt
```

### 1.3.2 Effects of Initial Population Size

We first set up several different initial values, provide a fixed $\lambda$, and set times from zero to 4.

```{r}
# Book default
N0 <- c(10, 20, 30)
lambda <- 2
time <- 0:4
```

We calculate population sizes at once using `sapply` to _apply_ a function (`n*lambda^time`) to each element of the first argument (each element of `N0`).

```{r}
# Book default
Nt.s <- sapply(N0, function(n) n * lambda^time)
Nt.s
```

```{r}
# JC

# A few points on what's wrong with the book's approach:
# - The function is defined as a "lambda function", which means it doesn't exist and is only applied within the call to sapply (this is fine for functions that only take one argument)
# - The lambda function is specified to take only argument n, but it should in fact take n, lambda and time
# - By not having them as arguments, the function searches the global enviornment for a matching object and this is very very bad. It's an easy way to screw up your code and never notice it
# 
# Solutions? Yeah:
# - Create an explicit function that takes the three parameters needed
# - Call that function using whatever approach you feel more comfortable with

# Define a function
grow <- function(n, lambda, time) {
  n * lambda^time
}

# Use the sapply approach, and take advantage of the "..." argument to pass lambda and time
Nt.s <- sapply(N0, grow, lambda = lambda, time = time)
Nt.s



# A tidy approach is to use a tibble and mutate
# Create a tibble with all combinations of time and N0
Nt_s_df <- expand.grid(time = 0:4,
                       N0 = c(10, 20, 30)) %>% 
  as_tibble() %>% 
  mutate(Nt = grow(n = N0, lambda = lambda, time = time))
Nt_s_df

# A functional programming approach is better, because it's easier to
# parallelize and generalize across many more parameters
# Create a tibble with all combinations of time and N0
Nt_s_df_fp <- expand.grid(time = 0:4,
                       N0 = c(10, 20, 30)) %>% 
  as_tibble() %>% 
  mutate(Nt = grow(n = N0, lambda = lambda, time = time)) %>% 
  mutate(Nt = pmap_dbl(.l = list(n = N0, time = time),
                       .f = grow, lambda = lambda))
Nt_s_df_fp
```


The result is a matrix, and we see $N_0$ in the first row, and each population is in its own column. Note that population 2 is always twice as big as population 1.

#### Graphing a Matrix (Figs. 1.3a, 1.3b)

We can use matplot to plot a matrix vs. a single vector on the X-axis. By default it labels the points according to the number of the column

```{r}
# Book default
matplot(time, Nt.s, pch = 1:3)
```

```{r}
# JC
(plot_jc <- ggplot(data = Nt_s_df,
                   mapping = aes(x = time,
                                 y = Nt,
                                 color = as.character(N0),
                                 shape = as.character(N0))) +
   geom_point(size = 3) +
   theme_minimal() +
   guides(color = guide_legend(title = bquote(N[0])),
          shape = guide_legend(title = bquote(N[0])))
 )
```


We can also plot it with a log scale on the y-axis. 
``` {r}
# Book default
matplot(time, Nt.s, log = "y", pch = 1:3)
```

```{r}
# JC
#We can just transform the axis
plot_jc +
  scale_y_continuous(trans = "log")
```


### 1.3.3 Effects of different per capita growth rates

Here we demonstrate the effects on growth of $\lambda > 1$ and $\lambda < 1$. We set $N_0 = 100$, and time, and then pick three different $\lambda$.
```{r}
# Book default
N0 <- 100
time <- 0:3
lambdas <- c(0.5, 1, 1.5)
```

We use `sapply` again to apply the geometric growth function to each $\lambda$. This time, `x` stands for each $\lambda$, which our function then uses to calculate population size. We then plot it, and add a reference line and a little text.

```{r}
# Book default
N.all <- sapply(lambdas, function(x) N0 * x^time)
matplot(time, N.all, xlab = "Years", ylab = "N", pch = 1:3)
abline(h = N0, lty = 3)
text(0.5, 250, expression(lambda > 1), cex = 1.2)
text(0.5, 20, expression(lambda < 1), cex = 1.2)
```

```{r}
# JC
# Combinations of lambda and time
expand.grid(time = 0:4,
            lambda = c(0.5, 1, 1.5)) %>% 
  as_tibble() %>% 
  mutate(Nt = grow(n = N0, lambda = lambda, time = time)) %>% #Calculate Nt
  ggplot(mapping = aes(x = time,
                       y = Nt,
                       color = as.character(lambda),
                       shape = as.character(lambda))) +
  geom_point(size = 3) +
  theme_minimal() +
   guides(color = guide_legend(title = bquote(lambda)),
          shape = guide_legend(title = bquote(lambda))) +
  geom_hline(yintercept = N0, linetype = "dashed") + #add horizontal line
  annotate(geom = "text", x = 0.5, y = 250, label = expression(lambda > 1), size = 6) + # Add lambda text
  annotate(geom = "text", x = 0.5, y = 20, label = expression(lambda < 1), size = 6) +
  labs(x = "Years", y = "N")
  
```


The reference line is a `h`orizontal line with the `l`ine `ty`pe dotted. Our text simply indicates the regions of positive and negative growth.

### 1.3.4 Average growth rate

#### Comparing arithmetic and geometric averages (Fig. 1.5)

First we select the number of observed $R$ $(t = 5)$; this will require that we use six years of Song Sparrow data.

```{r}
# Book default
t <- 5
data(sparrows)
SS6 <- sparrows[1:(t + 1), ]
```

```{r}
# JC
data(sparrows)
SS6_jc <- sparrows %>% 
  head(n = t + 1) #Coincidentally, the default in head() is 6... but anyways
```



Next we calculate $\lambda$ for each generation, from $t$ to $t + 1$, and calculate the arithmetic and geometric means.

```{r}
# Book default
SSgr <- SS6$Count[2:(t + 1)]/SS6$Count[1:t]
lam.A <- sum(SSgr)/t
# (I actually think this is better...)
lam.G <- prod(SSgr)^(1/t)
```

```{r}
# JC
SS_gr_jc <- SS6_jc %>% 
  mutate(SSgr = Count / lag(Count))

# Note that this is does not use a normal pipe!!!
# This is the "exposition operator", it's the equivalent of $
# Fun fact, the pipe ( %>% ) is NOT from dplyr or tidyr - they stole it.
# It comes from the magrittr package, which has many tidy-oriented functions
# There's also a %<>% and a %T% operators!
lam_A_jc <- SS_gr_jc %$% 
  sum(SSgr, na.rm = T) / t

lam_G_jc <- SS_gr_jc %$%
  prod(SSgr, na.rm = T) ^ (1 / t)
```


Now we can plot the data, and the projections based on the two averages (Fig. 1.5).

```{r}
# Book default
N0 <- SS6$Count[1]
plot(0:t, SS6$Count, ylab = "Projected Population Size")
lines(0:t, N0 * lam.A^(0:t), lty = 2)
lines(0:t, N0 * lam.G^(0:t), lty = 1)
legend(0, 70, 
       c("Arithmetic Ave.", "Geometric Ave."),
       title = "Projections Based On:", 
       lty = 2:1, bty = "n", xjust = 0)
```

```{r}
# JC
# First approach (looks tidy, but it's not perfect)
SS_gr_jc %>% 
  mutate(aritm = N0 * lam_A_jc^(0:t),
         geome = N0 * lam_G_jc^(0:t)) %>% 
  ggplot(mapping = aes(x = Year, y = Count)) +
  geom_point() +
  geom_line(aes(y = aritm), linetype = "dashed") +
  geom_line(aes(y = geome)) +
  theme_minimal()

# The above approach made it difficult to add an automatic legend
# This should be better
SS_gr_jc %>% 
  mutate(Arithmetic = N0 * lam_A_jc^(0:t),
         Geometric = N0 * lam_G_jc^(0:t)) %>% 
  select(Year, Count, Arithmetic, Geometric) %>% 
  gather(Fit, value, -c(Year, Count)) %>% 
  ggplot(mapping = aes(x = Year)) +
  geom_point(aes(y = Count)) +
  geom_line(aes(y = value, linetype = Fit)) +
  theme_minimal() +
  theme(legend.justification = c(0, 1),
        legend.position = c(0, 1))
```


## 1.4 Continuous Exponential Growth

### 1.4.1 Motivating continuous exponential growth

#### Numerical approximation of _e_

Here we use brute force to try to get an approximate solution to eq. 1.9. We’ll let n be the number of divisions within one year. This implies that the finite rate of increase during each of these fractional time steps is $r_d/n$. Let the $\lambda = 2$ and therefore $r_d = 1$. Note that because $N_0 = 1$, we could ignore it, but let’s keep it in for completeness.

```{r}
n <- 0:100
N0 <- 1
rd <- 1
```

Next, we calculate $\left( 1 + \frac{r_d}{n} \right)^n$ for ever larger values of $n$.
```{r}
N1 <- N0 * (1 + rd/n)^n
```

Last, we plot the ratio and add some fancy math text to the plot (see `?plotmath` for details on mathematical typesetting in R).

```{r}
plot(n, N1/N0, type = "l")
text(50, 2, "For n = 100,")
text(50, 1.6, 
     bquote((1+frac("r"["d"],"n"))^"n" == .(round(N1[101]/N0, + 3))))
```

Fig. 1.6: The limit to subdividing reproduction into smaller steps. We can compare this numerical approximation to the true value, $e^1 = 2.718$.

#### Projecting a continuous population

We select five different values for $r$: two negative, zero, and two positive. We let $t$ include the integers from 1 to 100. We then use `sapply` to apply our function of continuous exponential growth to each $r$, across all time steps. This results in a matrix where each row is the population size at each time $t$, and each column uses a different $r$.

```{r}
# Book default

r <- c(-0.03, -0.02, 0, 0.02, 0.03)
N0 <- 2
t <- 1:100
cont.mat <- sapply(r, function(ri) N0 * exp(ri * t))
```

```{r}
# JC

# Again, I explicitly define a function
grow_cont <- function(n, r, t) {
  n * exp(r * t)
}

# And use a tidy approach to it
cont_mat_jc <- expand.grid(time = 1:100,
                           r = c(-0.03, -0.02, 0, 0.02, 0.03)) %>% 
  as_tibble() %>% 
  mutate(N = grow_cont(n = N0, r = r, t = time))
```


Next we create side-by-side plots, using both arithmetic and logarithmic scales, and add a legend.
```{r}
layout(matrix(1:2, nrow = 1))
matplot(t, cont.mat, type = "l", ylab = "N", col = 1)
legend("topleft", paste(rev(r)), 
       lty = 5:1, col = 1, bty = "n",
       title = "r")
matplot(t, cont.mat, type = "l", ylab = "N", log = "y", col = 1)
```

```{r}
cont_mat_plot <- ggplot(data = cont_mat_jc,
                        mapping = aes(x = time, y = N, linetype = as.character(r))) +
  geom_line() +
  theme(legend.justification = c(0, 1),
        legend.position = c(0, 1)) +
  guides(linetype = guide_legend(title = "Intrinsic growth rate (r)"))

cont_mat_plot_log <- cont_mat_plot +
  theme(legend.position = "None") + #remove the legend
  scale_y_continuous(trans = "log", breaks = scales::log_breaks(6))

plot_grid(cont_mat_plot, cont_mat_plot_log, ncol = 2)
```


### 1.4.3 Doubling (and tripling) time

#### Creating a function for doubling time

We can create a function for this formula, and then evaluate it for different values of $m$ and $r$. For $m = 2$, we refer to this as “doubling time.” When we define the function and include arguments $r$ and $m$, we also set a default value for `m = 2`. This way, we do not always have to type a value for $m$; by default the function will return the doubling time.
```{r}
m.time <- function(r, m = 2) {
  log(m)/r
}
```

Now we create a vector of $r$, and then use `m.time` to generate a vector of doubling times.
```{r}
rs <- c(0, 1, 2)
m.time(rs)
# [1]    Inf 0.6931 0.3466
```

Note that R tells us that when $r = 0$, it takes an infinite (`Inf`) amount of time to double. This is what we get when we try to divide by zero!

## 1.6 Modeling with Data: Simulated Dynamics

### 1.6.2 Looking at and collecting the data

```{r}
names(sparrows)
# [1] "Year"           "Count"          "ObserverNumber"
attach(sparrows)
```

Now we plot these counts through time (Fig. 1.8).

```{r}
plot(Count ~ Year, type = "b")
```
```{r}
obs.R <- Count[-1]/Count[-length(Count)]
```

```{r}
plot(obs.R ~ Year[-length(Count)])
abline(h = 1, lty = 3)
```

### 1.6.3 One simulation

```{r}
years <- 50
set.seed(3)
sim.Rs <- sample(x = obs.R, size = years, replace = TRUE)

output <- numeric(years + 1)

output[1] <- Count[Year == max(Year)]

for (t in 1:years) output[t + 1] <- {
  output[t] * sim.Rs[t]
}

plot(0:years, output, type = "l")
```

### 1.6.4 Multiple simulations

```{r}
sims = 10
sim.RM <- matrix(sample(obs.R, sims * years, replace = TRUE),
                 nrow = years, ncol = sims)

output[1] <- Count[Year == max(Year)]
outmat <- sapply(1:sims, function(i) {
  for (t in 1:years) output[t + 1] <- output[t] * sim.RM[t, i]
  output
  })

matplot(0:years, outmat, type = "l", log = "y")

```

### 1.6.5 Many simulations, with a function

```{r}
PopSim <- function(Rs, N0, years = 50, sims = 10) {
  sim.RM = matrix(sample(Rs, size = sims * years, replace = TRUE),
                  nrow = years, ncol = sims)
  output <- numeric(years + 1)
  output[1] <- N0
  outmat <- sapply(1:sims, function(i) {
    for (t in 1:years) output[t + 1] <- round(output[t] * sim.RM[t, i], 0)
    output
  })
  return(outmat) 
}
```

```{r}
system.time(output <- PopSim(Rs = obs.R, N0 = 43, sims = 1000))
#  user  system elapsed
# 0.404   0.004   0.407
```

This tells me that it took less than half a second to complete 1000 simulations. That helps me understand how long 100,000 simulations might take. We also check the dimensions of the output, and they make sense.
``` {r}
dim(output)
# [1] 51 1000
```

### 1.6.6 Analyzing results

```{r}
N.2053 <- output[51, ]
summary(N.2053, digits = 6)
# Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
#  0.0     14.0     66.0   1124.6    291.8 332236.0
```

``` {r}
quantile(N.2053, prob = c(0.0275, 0.975))
# 2.75% 97.5%
#     0  5967
```

```{r}
hist(N.2053, main = "N")
hist(log10(N.2053 + 1), main = "log(N+1)")
abline(v = log10(quantile(N.2053, prob = c(0.0275, 0.975)) + 1), 
       lty = 3)
```

```{r}
logOR <- log(obs.R)
n <- length(logOR)
t.quantiles <- qt(c(0.025, 0.975), df = n - 1)

se <- sqrt(var(logOR)/n)
CLs95 <- mean(logOR) + t.quantiles * se

R.limits <- exp(CLs95)
R.limits
# [1] 0.8968 1.1302

N.Final.95 <- Count[Year == max(Year)] * R.limits^50
round(N.Final.95)
# [1] 0 19528
```

```{r}
qqplot(qt(ppoints(n), df = n - 1), scale(logOR))
qqline(scale(logOR))
```

## End of chapter questions

### 1.1. Geometric growth Analyze the following data, relying on selected snip- pets of previous code.

a. In the years 1996 through 2005, lily population sizes are $N = 150, 100, 125, 200, 225, 150, 100, 175, 100, 150$. Make a graph of population size versus time. 
b. Calculate $R$ for each year; graph $R$ vs. time.
c. Calculate arithmetic and geometric average growth rates of this population. 
d. Based on the appropriate average growth rate, what would be the expected population size in 2025? What would the estimated population size be if you used the inappropriate mean? Do not use simulation for this.
e. Given these data, develop simulations as above with the user-defined function, `PopSim`. Describe the distribution of projected population sizes for 2010.

### 1.2. Doubling Time

a. Derive the formula for doubling time in a population with continuous exponential growth.
b. What is the formula for tripling time?
c. If we are modeling humans or _E. coli_, would a model of geometric, or exponential growth be better? Why?
d. If an _E. coli_ population grew from 1000 cells to 2 × 10^9^ cells in 6 h, what would its intrinsic rate of increase be? Its doubling time?

### 1.3. Human Population Growth

a. There were about 630 million people on the planet in 1700, and 6.3 billion in 2003 [33]. What was the intrinsic rate of increase, r?
b. Graph the model of human population size population size from 1700 to 2020.
c. Add points on the graph indicating the population doublings from 1700 onward.
d. What will prevent humans from outweighing the planet by the end of this century? What controls human population growth? Do these controls vary spatially across the planet? See Cohen [33] to get going.

### 1.4. R functions

Find the R functions in Chapter 1. Demonstrate their uses.
